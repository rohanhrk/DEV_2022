{"version":3,"names":["generateUid","scope","denyList","name","uid","i","_generateUid","has","declare","types","t","template","assertVersion","inherits","syntaxClassStaticBlock","default","pre","enableFeature","file","FEATURES","staticBlocks","visitor","ClassBody","classBody","privateNames","Set","body","get","path","isPrivate","add","node","isStaticBlock","staticBlockPrivateId","staticBlockRef","privateName","identifier","replacement","blockBody","length","isExpressionStatement","expression","ast","replaceWith","classPrivateProperty"],"sources":["../src/index.ts"],"sourcesContent":["import { declare } from \"@babel/helper-plugin-utils\";\nimport syntaxClassStaticBlock from \"@babel/plugin-syntax-class-static-block\";\nimport type { Scope } from \"@babel/traverse\";\n\nimport {\n  enableFeature,\n  FEATURES,\n} from \"@babel/helper-create-class-features-plugin\";\n\n/**\n * Generate a uid that is not in `denyList`\n *\n * @param {Scope} scope\n * @param {Set<string>} denyList a deny list that the generated uid should avoid\n * @returns\n */\nfunction generateUid(scope: Scope, denyList: Set<string>) {\n  const name = \"\";\n  let uid;\n  let i = 1;\n  do {\n    uid = scope._generateUid(name, i);\n    i++;\n  } while (denyList.has(uid));\n  return uid;\n}\n\nexport default declare(({ types: t, template, assertVersion }) => {\n  assertVersion(\"^7.12.0\");\n\n  return {\n    name: \"proposal-class-static-block\",\n    inherits: syntaxClassStaticBlock.default,\n\n    pre() {\n      // Enable this in @babel/helper-create-class-features-plugin, so that it\n      // can be handled by the private fields and methods transform.\n      enableFeature(this.file, FEATURES.staticBlocks, /* loose */ false);\n    },\n\n    visitor: {\n      // Run on ClassBody and not on class so that if @babel/helper-create-class-features-plugin\n      // is enabled it can generte optimized output without passing from the intermediate\n      // private fields representation.\n      ClassBody(classBody) {\n        const { scope } = classBody;\n        const privateNames = new Set<string>();\n        const body = classBody.get(\"body\");\n        for (const path of body) {\n          if (path.isPrivate()) {\n            privateNames.add(path.get(\"key.id\").node.name);\n          }\n        }\n        for (const path of body) {\n          if (!path.isStaticBlock()) continue;\n          const staticBlockPrivateId = generateUid(scope, privateNames);\n          privateNames.add(staticBlockPrivateId);\n          const staticBlockRef = t.privateName(\n            t.identifier(staticBlockPrivateId),\n          );\n\n          let replacement;\n          const blockBody = path.node.body;\n          // We special-case the single expression case to avoid the iife, since\n          // it's common.\n          if (blockBody.length === 1 && t.isExpressionStatement(blockBody[0])) {\n            replacement = blockBody[0].expression;\n          } else {\n            replacement = template.expression.ast`(() => { ${blockBody} })()`;\n          }\n\n          path.replaceWith(\n            t.classPrivateProperty(\n              staticBlockRef,\n              replacement,\n              [],\n              /* static */ true,\n            ),\n          );\n        }\n      },\n    },\n  };\n});\n"],"mappings":";;;;;;AAAA;AACA;AAGA;AAYA,SAASA,WAAW,CAACC,KAAY,E