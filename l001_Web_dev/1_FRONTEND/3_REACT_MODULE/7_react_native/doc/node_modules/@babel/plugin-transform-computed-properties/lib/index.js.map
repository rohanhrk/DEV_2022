{"version":3,"names":["DefineAccessorHelper","template","expression","ast","_compact","declare","api","options","assertVersion","setComputedProperties","assumption","loose","pushComputedProps","pushComputedPropsLoose","pushComputedPropsSpec","buildDefineAccessor","state","type","obj","key","fn","helper","availableHelper","addHelper","file","get","id","scope","generateUidIdentifier","push","init","set","t","cloneNode","callExpression","stringLiteral","getValue","prop","isObjectProperty","value","isObjectMethod","functionExpression","params","body","generator","async","pushAssign","objId","expressionStatement","assignmentExpression","memberExpression","computed","isLiteral","pushAccessorDefine","computedProps","initPropExpression","kind","isIdentifier","name","length","info","single","toComputedKey","visitor","ObjectExpression","exit","path","node","parent","hasComputed","properties","initProps","foundComputed","isSpreadElement","generateUidIdentifierBasedOnNode","objectExpression","variableDeclaration","variableDeclarator","replaceWith","replaceWithMultiple"],"sources":["../src/index.ts"],"sourcesContent":["import { types as t } from \"@babel/core\";\nimport type { PluginPass } from \"@babel/core\";\nimport { declare } from \"@babel/helper-plugin-utils\";\nimport template from \"@babel/template\";\nimport type { Scope } from \"@babel/traverse\";\n\nexport interface Options {\n  loose?: boolean;\n}\n\ntype PropertyInfo = {\n  scope: Scope;\n  objId: t.Identifier;\n  body: t.Statement[];\n  computedProps: t.ObjectMember[];\n  initPropExpression: t.ObjectExpression;\n  state: PluginPass;\n};\n\n// TODO(Babel 8): Remove this\nconst DefineAccessorHelper = template.expression.ast`\nfunction (type, obj, key, fn) {\n  var desc = { configurable: true, enumerable: true };\n  desc[type] = fn;\n  return Object.defineProperty(obj, key, desc);\n}`;\n// @ts-expect-error undocumented _compact node property\nDefineAccessorHelper._compact = true;\n\nexport default declare((api, options: Options) => {\n  api.assertVersion(7);\n\n  const setComputedProperties =\n    api.assumption(\"setComputedProperties\") ?? options.loose;\n\n  const pushComputedProps = setComputedProperties\n    ? pushComputedPropsLoose\n    : pushComputedPropsSpec;\n\n  function buildDefineAccessor(\n    state: PluginPass,\n    type: \"get\" | \"set\",\n    obj: t.Expression,\n    key: t.Expression,\n    fn: t.Expression,\n  ) {\n    let helper: t.Identifier;\n    if (state.availableHelper(\"defineAccessor\")) {\n      helper = state.addHelper(\"defineAccessor\");\n    } else {\n      // Fallback for @babel/helpers <= 7.20.6, manually add helper function\n      // TODO(Babel 8): Remove this\n      const file = state.file;\n      helper = file.get(\"fallbackDefineAccessorHelper\");\n      if (!helper) {\n        const id = file.scope.generateUidIdentifier(\"defineAccessor\");\n        file.scope.push({\n          id,\n          init: DefineAccessorHelper,\n        });\n        file.set(\"fallbackDefineAccessorHelper\", (helper = id));\n      }\n      helper = t.cloneNode(helper);\n    }\n\n    return t.callExpression(helper, [t.stringLiteral(type), obj, key, fn]);\n  }\n\n  /**\n   * Get value of an object member under object expression.\n   * Returns a function expression if prop is a ObjectMethod.\n   *\n   * @param {t.ObjectMember} prop\n   * @returns t.Expression\n   */\n  function getValue(prop: t.ObjectMember) {\n    if (t.isObjectProperty(prop)) {\n      return prop.value as t.Expression;\n    } else if (t.isObjectMethod(prop)) {\n      return t.functionExpression(\n        null,\n        prop.params,\n        prop.body,\n        prop.generator,\n        prop.async,\n      );\n    }\n  }\n\n  function pushAssign(\n    objId: t.Identifier,\n    prop: t.ObjectMember,\n    body: t.Statement[],\n  ) {\n    body.push(\n      t.expressionStatement(\n        t.assignmentExpression(\n          \"=\",\n          t.