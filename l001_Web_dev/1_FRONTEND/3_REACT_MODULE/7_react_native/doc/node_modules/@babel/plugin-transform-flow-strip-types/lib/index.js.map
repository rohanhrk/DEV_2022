{"version":3,"names":["declare","api","opts","assertVersion","FLOW_DIRECTIVE","skipStrip","requireDirective","allowDeclareFields","name","inherits","syntaxFlow","visitor","Program","path","file","ast","comments","directiveFound","comment","test","value","replace","trim","ignore","ImportDeclaration","node","specifiers","length","typeCount","forEach","importKind","remove","Flow","buildCodeFrameError","ClassPrivateProperty","typeAnnotation","Class","implements","get","child","isClassProperty","decorators","variance","AssignmentPattern","left","optional","Function","params","type","shift","i","param","t","isMethod","predicate","TypeCastExpression","expression","isTypeCastExpression","replaceWith","CallExpression","typeArguments","OptionalCallExpression","NewExpression"],"sources":["../src/index.ts"],"sourcesContent":["import { declare } from \"@babel/helper-plugin-utils\";\nimport syntaxFlow from \"@babel/plugin-syntax-flow\";\nimport { types as t } from \"@babel/core\";\nimport type { NodePath } from \"@babel/traverse\";\n\nexport interface Options {\n  requireDirective?: boolean;\n  allowDeclareFields?: boolean;\n}\n\nexport default declare((api, opts: Options) => {\n  api.assertVersion(7);\n\n  const FLOW_DIRECTIVE = /(@flow(\\s+(strict(-local)?|weak))?|@noflow)/;\n\n  let skipStrip = false;\n\n  const { requireDirective = false } = opts;\n\n  if (!process.env.BABEL_8_BREAKING) {\n    // eslint-disable-next-line no-var\n    var { allowDeclareFields = false } = opts;\n  }\n\n  return {\n    name: \"transform-flow-strip-types\",\n    inherits: syntaxFlow,\n\n    visitor: {\n      Program(\n        path,\n        {\n          file: {\n            ast: { comments },\n          },\n        },\n      ) {\n        skipStrip = false;\n        let directiveFound = false;\n\n        if (comments) {\n          for (const comment of comments) {\n            if (FLOW_DIRECTIVE.test(comment.value)) {\n              directiveFound = true;\n\n              // remove flow directive\n              comment.value = comment.value.replace(FLOW_DIRECTIVE, \"\");\n\n              // remove the comment completely if it only consists of whitespace and/or stars\n              if (!comment.value.replace(/\\*/g, \"\").trim()) {\n                comment.ignore = true;\n              }\n            }\n          }\n        }\n\n        if (!directiveFound && requireDirective) {\n          skipStrip = true;\n        }\n      },\n      ImportDeclaration(path) {\n        if (skipStrip) return;\n        if (!path.node.specifiers.length) return;\n\n        let typeCount = 0;\n\n        // @ts-expect-error importKind is only in importSpecifier\n        path.node.specifiers.forEach(({ importKind }) => {\n          if (importKind === \"type\" || importKind === \"typeof\") {\n            typeCount++;\n          }\n        });\n\n        if (typeCount === path.node.specifiers.length) {\n          path.remove();\n        }\n      },\n\n      Flow(\n        path: NodePath<\n          t.Flow | t.ImportDeclaration | t.ExportDeclaration | t.ImportSpecifier\n        >,\n      ) {\n        if (skipStrip) {\n          throw path.buildCodeFrameError(\n            \"A @flow directive is required when using Flow annotations with \" +\n              \"the `requireDirective` option.\",\n          );\n        }\n\n        path.remove();\n      },\n\n      ClassPrivateProperty(path) {\n        if (skipStrip) return;\n        path.node.typeAnnotation = null;\n      },\n\n      Class(path) {\n        if (skipStrip) return;\n        path.node.implements = null;\n\n        // We do this here instead of in a `ClassProperty` visitor because the class transform\n        // would transform the class before we reached the class property.\n        path.get(\"body.body\").forEach(child => {\n          if (child.isClassProperty()) {\n            const { node } = child;\n\n            if (!process.env.BABEL_8_BREAKING) {\n              if (!allowDeclareFields && node.declare) {\n                throw child.buildCodeFrameError(\n                  `The 'declare' modifier is only allowed when the ` +\n                    `'allowDeclareFields' option of ` +\n                    `@babel/plugin-transform-flow-strip-types or ` +\n                    `@babel/preset-flow is enabled.`,\n                );\n              }\n            }\n\n            if (node.declare) {\n              child.remove();\n            } else {\n              if (!process.env.BABEL_8_BREAKING) {\n                if (!allowDeclareFields && !node.value && !node.decorators) {\n                  child.remove();\n                  return;\n                }\n              }\n\n              node.variance = null;\n              node.typeAnnotation = null;\n            }\n          }\n        });\n      },\n\n      AssignmentPattern({ node }) {\n        if (skipStrip) return;\n        // @ts-expect-error optional is not in ObjectPattern\n        if (node.left.optional) {\n          // @ts-expect-error optional is not in ObjectPattern\n          node.left.optional = false;\n        }\n      },\n\n      Function({ node }) {\n        if (skipStrip) return;\n        if (\n          node.params.length > 0 &&\n          node.params[0].type === \"Identifier\" &&\n          node.params[0].name === \"this\"\n        ) {\n          node.params.shift();\n        }\n        for (let i = 0; i < node.params.length; i++) {\n          let param = node.params[i];\n          if (param.type === \"AssignmentPattern\") {\n            // @ts-expect-error: refine AST types, the left of an assignment pattern as a binding\n            // must not be a MemberExpression\n            param = param.left;\n          }\n          // @ts-expect-error optional is not in ObjectPattern\n          if (param.optional) {\n            // @ts-expect-error