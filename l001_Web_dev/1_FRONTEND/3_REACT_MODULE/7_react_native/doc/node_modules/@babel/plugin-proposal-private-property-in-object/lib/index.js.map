{"version":3,"names":["declare","api","opt","assertVersion","types","t","template","loose","classWeakSets","WeakMap","fieldsWeakSets","unshadow","name","targetScope","scope","hasOwnBinding","rename","parent","injectToFieldInit","fieldPath","expr","before","node","value","get","insertBefore","insertAfter","set","unaryExpression","injectInitialization","classPath","init","firstFieldPath","consturctorPath","el","isClassProperty","isClassPrivateProperty","static","isClassMethod","kind","injectConstructorInit","expressionStatement","getWeakSetId","weakSets","outerClass","reference","inject","id","generateUidIdentifier","expression","ast","cloneNode","newExpr","newExpression","identifier","annotateAsPure","inherits","syntaxPlugin","default","pre","enableFeature","file","FEATURES","privateIn","visitor","BinaryExpression","path","state","operator","isPrivateName","left","privateElement","findParent","isClass","find","isPrivate","key","parentPath","isPattern","replaceWith","type","buildCheckInRHS","right"],"sources":["../src/index.ts"],"sourcesContent":["import { declare } from \"@babel/helper-plugin-utils\";\nimport syntaxPlugin from \"@babel/plugin-syntax-private-property-in-object\";\nimport {\n  enableFeature,\n  FEATURES,\n  injectInitialization as injectConstructorInit,\n  buildCheckInRHS,\n} from \"@babel/helper-create-class-features-plugin\";\nimport annotateAsPure from \"@babel/helper-annotate-as-pure\";\nimport type * as t from \"@babel/types\";\nimport type { NodePath, Scope } from \"@babel/traverse\";\n\nexport interface Options {\n  loose?: boolean;\n}\nexport default declare((api, opt: Options) => {\n  api.assertVersion(7);\n  const { types: t, template } = api;\n  const { loose } = opt;\n\n  // NOTE: When using the class fields or private methods plugins,\n  // they will also take care of '#priv in obj' checks when visiting\n  // the ClassExpression or ClassDeclaration nodes.\n  // The visitor of this plugin is only effective when not compiling\n  // private fields and methods.\n\n  const classWeakSets: WeakMap<t.Class, t.Identifier> = new WeakMap();\n  const fieldsWeakSets: WeakMap<\n    t.ClassPrivateProperty | t.ClassPrivateMethod,\n    t.Identifier\n  > = new WeakMap();\n\n  function unshadow(name: string, targetScope: Scope, scope: Scope) {\n    while (scope !== targetScope) {\n      if (scope.hasOwnBinding(name)) scope.rename(name);\n      scope = scope.parent;\n    }\n  }\n\n  function injectToFieldInit(\n    fieldPath: NodePath<t.ClassPrivateProperty | t.ClassProperty>,\n    expr: t.Expression,\n    before = false,\n  ) {\n    if (fieldPath.node.value) {\n      const value = fieldPath.get(\"value\");\n      if (before) {\n        value.insertBefore(expr);\n      } else {\n        value.insertAfter(expr);\n      }\n    } else {\n      fieldPath.set(\"value\", t.unaryExpression(\"void\", expr));\n    }\n  }\n\n  function injectInitialization(\n    classPath: NodePath<t.Class>,\n    init: t.Expression,\n  ) {\n    let firstFieldPath;\n    let consturctorPath;\n\n    for (const el of classPath.get(\"body.body\")) {\n      if (\n        (el.isClassProperty() || el.isClassPrivateProperty()) &&\n        !el.node.static\n      ) {\n        firstFieldPath = el;\n        break;\n      }\n      if (!consturctorPath && el.isClassMethod({ kind: \"constructor\" })) {\n        consturctorPath = el;\n      }\n    }\n\n    if (firstFieldPath) {\n      injectToFieldInit(firstFieldPath, init, true);\n    } else {\n      injectConstructorInit(classPath, consturctorPath, [\n        t.expressionStatement(init),\n      ]);\n    }\n  }\n\n  function getWeakSetId<Ref extends t.Node>(\n    weakSets: WeakMap<Ref, t.Identifier>,\n    outerClass: NodePath<t.Class>,\n    reference: NodePath<Ref>,\n    name = \"\",\n    inject: (\n      reference: NodePath<Ref>,\n      expr